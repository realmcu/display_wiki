# GPU 内存开销分析

本文档详细分析 **2.5D GPU** 和 **3D GPU** 的内存开销差异，帮助开发者理解不同 GPU 架构的内存需求和优化策略。

> **GPU 分类说明**：根据 VeriSilicon GPU 产品线，GPU 可分为：
>
> | GPU 类型 | 支持的 API | 典型产品 | 内存特征 |
> |---------|-----------|---------|---------|
> | **纯 2.5D GPU** | OpenVG, VGLite | GCNanoUltraV | 需要 Path Buffer（路径缓冲），无 Depth Buffer |
> | **纯 3D GPU** | OpenGL ES, Vulkan | GCNanoUltra31 | 需要 Depth Buffer（深度缓冲），无 Path Buffer |
> | **混合型 GPU** | OpenVG + OpenGL ES | GCNano3DVG, GC555 | 同时包含两者的内存开销 |
>
> **本文档重点对比纯 2.5D GPU 与纯 3D GPU 的内存开销特征。** 混合型 GPU 的内存开销为两者之和，不在本文对比范围内。

**更新日期**: 2026-02-27
**目标读者**: 系统架构师、SoC 设计工程师、嵌入式软件开发者

---

## 1. 概述

### 1.1 GPU 内存开销的定义

GPU 内存开销是指图形处理单元在渲染过程中占用的内存资源。对于2.5D GPU 和 3D GPU，内存开销构成复杂且差异显著，直接影响系统设计的内存容量选型和带宽规划。

---

## 2. 内存开销组成详解

### 2.1 2.5D GPU 内存组成

以下表格列出 2.5D GPU（OpenVG/VGLite）的内存开销组成，基于 VeriSilicon GCNanoUltraV 架构：

| 缓冲区类型 | 是否必需 | 典型大小 | 位置 | 说明 |
|-----------|---------|---------|------|------|
| **Frame Buffer<br>（帧缓冲）** | ✅ 必需 | 分辨率 × 像素字节 × 缓冲数 | 系统内存 | 存储最终渲染结果<br>例：640×480 RGB565 双缓冲 = 1.2 MB |
| **Tessellation Buffer<br>（扁平化缓冲）** | ✅ 必需 | 硬件固定<br>（几十 KB） | GPU 内部 SRAM | **硬件内部临时缓冲**<br>- 路径扁平化后的顶点<br>- 复杂路径可能溢出<br>- Geometry Engine 输出 |
| **Command Buffer<br>（命令缓冲）** | ✅ 必需 | 64-128 KB | 系统内存 | 存储 OpenVG 绘制命令<br>- vgDrawPath() 调用<br>- 变换矩阵设置<br>- 涂装参数配置 |
| **Image Cache<br>（图像缓存）** | ✅ 必需 | 100-500 KB | GPU 内部 | 纹理/图像数据缓存<br>- 渐变填充<br>- 图案填充<br>- 位图纹理 |
| **Anti-Aliasing Buffer<br>（抗锯齿缓冲）** | 🔶 可选 | 帧缓冲 × 采样倍数 | 系统内存 | MSAA 抗锯齿（2×/4×）<br>矢量图形本身较光滑，依赖度较低 |

> **重要说明**：
> - **Tessellation Buffer** 是硬件内部缓冲，大小固定，不占用系统内存
> - 复杂路径（如 Tiger Benchmark）可能触发 Tessellation Buffer 溢出
> - GPU 会自动分块处理（scissor into small boxes）来应对溢出

**2.5D GPU 总系统内存需求**：约 **1.5-2.5 MB**（不含抗锯齿，以 640×480 RGB565 为例）

---

### 2.2 3D GPU 内存组成

以下表格列出 3D GPU（OpenGL ES/Vulkan）的内存开销组成：

| 缓冲区类型 | 是否必需 | 典型大小 | 说明 |
|-----------|---------|---------|------|
| **Frame Buffer<br>（帧缓冲）** | ✅ 必需 | 分辨率 × 像素字节 × 缓冲数 | 存储最终渲染结果<br>例：480×480 RGB565 双缓冲 = 900 KB |
| **Depth Buffer<br>（深度缓冲 / Z-Buffer）** | ✅ 必需 | 分辨率 × 深度字节（2-4B） | 处理 3D 物体遮挡关系<br>例：480×480 D16 = 450 KB |
| **Vertex Buffer<br>（顶点缓冲）** | ✅ 必需 | 512 KB - 2 MB | 存储 3D 模型顶点数据<br>- 位置坐标（XYZ）<br>- 法向量（用于光照）<br>- 纹理坐标（UV）<br>- 顶点颜色 |
| **Index Buffer<br>（索引缓冲）** | ✅ 必需 | 顶点缓冲的 ~30% | 三角形网格索引<br>避免顶点数据重复存储 |
| **Texture Cache<br>（纹理缓存）** | ✅ 必需 | 4-16 MB | 3D 模型表面贴图<br>- 颜色贴图<br>- 法线贴图<br>- 环境贴图 |
| **Mipmap<br>（多级纹理）** | ✅ 支持 | 纹理大小 × 1.33 | 多层级纹理，提升远距离采样质量 |
| **Shader Cache<br>（着色器缓存）** | ✅ 必需 | 64-256 KB | 存储编译后的着色器程序<br>- 顶点着色器<br>- 片段着色器 |
| **Uniform Buffer<br>（统一变量缓冲）** | ✅ 必需 | 16-64 KB | 着色器常量数据<br>- 变换矩阵（MVP）<br>- 光照参数<br>- 材质属性 |
| **Command Buffer<br>（命令缓冲）** | ✅ 必需 | 256 KB - 1 MB | 存储 OpenGL ES 绘制命令<br>- glDrawElements() 调用<br>- 状态切换（纹理、着色器）<br>- Uniform 参数上传 |
| **Anti-Aliasing Buffer<br>（抗锯齿缓冲）** | 🔶 可选 | 帧缓冲 × 采样倍数 | MSAA/SSAA 抗锯齿<br>3D 几何边缘需要抗锯齿处理 |

**3D GPU 总内存需求**：约 **8-20 MB**（简单到中等复杂场景）

---

## 3. 各缓冲区详细说明

### 3.1 Frame Buffer（帧缓冲）

**通用于2.5D GPU 和 3D GPU**

帧缓冲存储最终显示到屏幕的像素数据。

**单缓冲大小计算**:
```
单缓冲大小 = 宽度 × 高度 × 每像素字节数
```

**色深对比**（以 480×480 为例）:

| 格式 | 每像素字节 | 单缓冲 | 双缓冲 |
|------|-----------|-------|-------|
| RGB565 | 2 | 450 KB | 900 KB |
| RGB888 | 3 | 675 KB | 1.35 MB |
| ARGB8888 | 4 | 900 KB | 1.8 MB |

**缓冲策略**:
- **单缓冲**: 最小内存，可能有撕裂
- **双缓冲**: 标准配置，防止撕裂
- **三缓冲**: 进一步减少延迟（×3 内存）

---

### 3.2 Depth Buffer（深度缓冲 / Z-Buffer）

**仅 3D GPU 需要**

深度缓冲存储每个像素的深度值（Z 坐标），用于正确处理 3D 物体的前后遮挡关系。

**深度格式对比**（以 480×480 为例）:

| 深度格式 | 每像素字节 | 缓冲大小 | 适用场景 |
|---------|-----------|---------|---------|
| 16-bit | 2 | 450 KB | 简单场景，深度范围 < 100 单位 |
| 24-bit | 3 | 675 KB | 通用场景，中等深度范围 |
| D24S8 (32-bit) | 4 | 900 KB | 深度 + 8-bit 模板，用于高级效果 |

**为什么2.5D GPU 不需要深度缓冲？**

2.5D GPU 渲染的是平面图形和 2.5D 效果（透视变形、图层合成），所有对象在同一平面或明确的图层顺序中，无需深度测试。

---

### 3.3 Tessellation Buffer（扁平化缓冲）

**仅 2.5D GPU 需要（硬件内部缓冲）**

Tessellation Buffer 是 2.5D GPU 的 **Geometry Engine 内部缓冲区**，用于存储路径扁平化（Tessellation）后的临时顶点数据。

**位置**: GPU 内部 SRAM（不占用系统内存）
**大小**: 硬件固定（通常几十 KB）
**作用**: 将贝塞尔曲线分解为三角形顶点

#### 工作流程

```
OpenVG 路径（贝塞尔曲线）
        ↓
Geometry Engine 路径解码
        ↓
Tessellation（扁平化）
        ↓
【Tessellation Buffer】← 存储临时顶点
        ↓
Rasterization（光栅化）
        ↓
Frame Buffer（最终输出）
```

#### Tessellation Buffer 溢出问题

**问题**：复杂路径扁平化后产生大量顶点，超过硬件缓冲区容量。

**典型场景**：
- Tiger Benchmark（240 个复杂路径）
- 高精度贝塞尔曲线（大量控制点）
- 大型矢量字体渲染

**硬件自动处理**：
```
GPU 检测到 Tessellation Buffer 溢出
     ↓
自动将路径 Bounding Box 分割成小块
     ↓
逐块进行 Tessellation
     ↓
分块光栅化，最终合并
```

**示例**（Tiger Benchmark）：
```
原始路径：240 个复杂贝塞尔曲线
扁平化后：约 50,000+ 顶点
Tessellation Buffer：仅能容纳 ~10,000 顶点
结果：自动分为 5+ 块处理
```

---

### 3.4 Vertex Buffer & Index Buffer（顶点缓冲 & 索引缓冲）

**仅 3D GPU 大量使用**

#### 3D GPU（512 KB - 2 MB）
- 存储大量 3D 模型的顶点数据
- 每个顶点包含：位置、法向量、纹理坐标、颜色

**3D 顶点数据大小计算**:
```
单顶点大小 = 位置(12B) + 法向量(12B) + UV坐标(8B) + 颜色(4B) = 36 字节

10,000 顶点：
  顶点缓冲：10,000 × 36 = 360 KB
  索引缓冲（15,000 三角形）：15,000 × 3 × 2 = 90 KB
  总计：450 KB
```

---

### 3.5 Image Cache / Texture Cache

**2.5D GPU 和 3D GPU 都需要，但用途和规模不同**

#### 2.5D GPU - Image Cache（100-500 KB）
- **位置**: GPU 内部缓存
- **用途**: 渐变填充、图案填充、位图纹理
- **特点**: 主要缓存小型渐变和图案，不需要大量纹理

**示例**（Tiger Benchmark）:
```
渐变填充数据：~50 KB
图案纹理：~100 KB
临时位图缓存：~50 KB
总计：~200 KB
```

**注意**: 2.5D GPU 的 Image Cache 远小于 3D GPU，因为：
- 矢量图形主要靠路径渲染，不依赖大量纹理
- 渐变和图案通常尺寸较小
- 不需要 Mipmap

#### 3D GPU（4-16+ MB）
- **用途**: 3D 模型表面贴图、环境贴图、法线贴图
- **特点**: 纹理数量多，支持 Mipmap（多层级）

**3D 纹理缓存组成**:
```
基础纹理（10 张 1024×1024）：
  未压缩：10 × 4 MB = 40 MB
  ETC2 压缩：10 × 1 MB = 10 MB
  含 Mipmap：10 MB × 1.33 = 13.3 MB

实际系统：8-16 MB（使用压缩 + 流式加载）
```

**纹理压缩对比**:

| 格式 | 压缩比 | 1024×1024 大小 | 质量 | GPU 支持 |
|------|-------|---------------|------|----------|
| RGBA8888 | 1:1 | 4 MB | 最高 | 所有 |
| ETC2 | 4:1 | 1 MB | 高 | OpenGL ES 3.0+ |
| ASTC 4×4 | 8:1 | 512 KB | 高 | 现代 GPU |
| ASTC 8×8 | 32:1 | 128 KB | 中 | 现代 GPU |

---

### 3.6 Shader Cache & Uniform Buffer

**仅 3D GPU 需要**

#### Shader Cache（着色器缓存，64-256 KB）
存储编译后的顶点着色器和片段着色器程序。

**示例**:
```
顶点着色器（基础变换 + 光照）：16 KB
片段着色器（纹理采样 + Phong 光照）：32 KB
5 组着色器程序：5 × 48 KB = 240 KB
```

#### Uniform Buffer（统一变量缓冲，16-64 KB）
存储着色器的常量数据：
- 模型-视图-投影矩阵（MVP Matrix）
- 光照参数（位置、颜色、强度）
- 材质属性（反射率、粗糙度）

**示例**:
```
每对象 Uniform 数据：
  MVP 矩阵：64 字节
  法向量矩阵：64 字节
  材质参数：32 字节
  光照参数：64 字节
  总计：224 字节

100 个对象：224 × 100 = 22.4 KB
```

---

### 3.7 Command Buffer（命令缓冲）

**2.5D GPU 和 3D GPU 都需要，但复杂度不同**

#### 2.5D GPU（64-128 KB）
存储 OpenVG 命令：
- `vgDrawPath()` 调用
- 变换矩阵设置
- 涂装（Paint）参数配置
- 图层混合模式

#### 3D GPU（256 KB - 1 MB）
存储 OpenGL ES 命令：
- `glDrawElements()` 调用（数量多）
- 状态切换（纹理绑定、着色器切换）
- Uniform 参数上传
- 帧缓冲对象（FBO）切换

**3D 命令缓冲更大的原因**:
- 绘制调用数量多（每个对象一次）
- 状态切换频繁（纹理、着色器、混合模式）
- 复杂的渲染管线（多个 pass）

---

### 3.8 Anti-Aliasing Buffer（抗锯齿缓冲）

**2.5D GPU 和 3D GPU 都支持，但内存开销巨大**

#### MSAA（多重采样抗锯齿）

| MSAA 倍数 | 额外内存（480×480 ARGB8888） | 适用场景 |
|-----------|----------------------------|---------|
| 无 | 0 | 基准 |
| 2× | +1.8 MB（帧缓冲 ×2） | 轻度抗锯齿 |
| 4× | +3.6 MB（帧缓冲 ×4） | 标准抗锯齿 |
| 8× | +7.2 MB（帧缓冲 ×8） | 高质量（桌面级） |

**2.5D GPU 的优势**: OpenVG 本身基于矢量，边缘更光滑，对 MSAA 依赖较低。

**3D GPU 替代方案**: FXAA（后处理，无额外内存）、TAA（时序抗锯齿，+1 帧缓冲）

---

## 4. 内存带宽需求

（待完成：带宽计算方法、2.5D GPU 与 3D GPU 的带宽对比）

---

## 5. 典型应用场景

（待完成：车载仪表、工业 HMI、手持游戏机的内存配置案例）

---

## 6. 优化策略

（待完成：纹理压缩、缓冲区复用、色深优化等）

---

## 7. 内存类型选型

（待完成：PSRAM vs DDR 选择指南）

---

## 8. 参考资料

- [3D GPU 概述](gpu-overview.md) - 渲染管线详细说明
- [2D/2.5D/3D GPU 技术对比](2d-vs-3d-gpu.md) - 硬件架构对比
- [PSRAM 带宽计算](../hardware/psram-bandwidth.md) - 带宽需求分析

---

**文档版本**: 2.0（重构中）
**最后更新**: 2026-02-27
**贡献者**: Display Wiki Team
