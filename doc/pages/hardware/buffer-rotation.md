# 横屏竖用方案分析

## 无外部硬件

```{mermaid}
flowchart LR
  FB[新帧准备] --> BLEND
  BLEND[渲染] --> ROT[旋转]
  ROT --> DMA[刷屏]
```

## 
有外部硬件

### 一般方案

```{mermaid}
flowchart LR
  FB[新帧准备] --> BLEND
  BLEND[渲染] --> HARD[硬件旋转]
  HARD --> DMA[刷屏]
```

### HoneyGUI 方案

```{mermaid}
flowchart LR
  FB[新帧准备]  --> BLEND1 --> ROT[硬件旋转]
  BLEND1[分段1渲染] --> BLEND2[分段2渲染] -->ROT2[硬件旋转]
  BLEND2--> BLEND12[分段3渲染]
  --> ROT3[硬件旋转] --> LCD[推屏]
```

## 旋转方式

- [x] 90度旋转
- [x] 180度旋转
- [x] 270度旋转


### 示例 1: 4×3 图像 90° 顺时针旋转

**源图像 (4×3):**
```
+---+---+---+---+
| A | B | C | D |  行 0
+---+---+---+---+
| E | F | G | H |  行 1
+---+---+---+---+
| I | J | K | L |  行 2
+---+---+---+---+
  0   1   2   3
```

**目标图像 (3×4) 90° 顺时针旋转后:**
```
+---+---+---+
| I | E | A |  行 0
+---+---+---+
| J | F | B |  行 1
+---+---+---+
| K | G | C |  行 2
+---+---+---+
| L | H | D |  行 3
+---+---+---+
  0   1   2
```

**映射表 (90° 顺时针):**
```
源 → 目标
(0,0) A → (2,0)
(1,0) B → (2,1)
(2,0) C → (2,2)
(3,0) D → (2,3)
(0,1) E → (1,0)
(1,1) F → (1,1)
(2,1) G → (1,2)
(3,1) H → (1,3)
(0,2) I → (0,0)
(1,2) J → (0,1)
(2,2) K → (0,2)
(3,2) L → (0,3)
```

### 示例 2: 4×3 图像 180° 旋转

**源图像 (4×3):**
```
+---+---+---+---+
| A | B | C | D |  行 0
+---+---+---+---+
| E | F | G | H |  行 1
+---+---+---+---+
| I | J | K | L |  行 2
+---+---+---+---+
```

**目标图像 (4×3) 180° 旋转后:**
```
+---+---+---+---+
| L | K | J | I |  行 0
+---+---+---+---+
| H | G | F | E |  行 1
+---+---+---+---+
| D | C | B | A |  行 2
+---+---+---+---+
```

### 示例 3: 4×3 图像 270° 顺时针旋转

**源图像 (4×3):**
```
+---+---+---+---+
| A | B | C | D |  行 0
+---+---+---+---+
| E | F | G | H |  行 1
+---+---+---+---+
| I | J | K | L |  行 2
+---+---+---+---+
```

**目标图像 (3×4) 270° 顺时针旋转后:**
```
+---+---+---+
| D | H | L |  行 0
+---+---+---+
| C | G | K |  行 1
+---+---+---+
| B | F | J |  行 2
+---+---+---+
| A | E | I |  行 3
+---+---+---+
```

## 方案评估

传统方案无硬件辅助，涉及CPU对memory的无序访问，效率低下。特别是PSRAM等串行接口的存储介质，对于少量数据访问存在大量额外开销，导致实际读写效率不足理论值的30%。

当有硬件辅助时，可以显著提升旋转效率，尤其在处理大量像素数据时，这类硬件可以通过cache、block搬运等方式，减少很多旋转时间开销。但是这段时间依然是不可避免的，只有等到旋转完成才能推送到显示器。

HoneyGUI方案通过将渲染任务分段并利用硬件加速，进一步优化了性能，使得硬件旋转与下一个分段的绘制同步进行，最终的时间开销只增加了一个分段旋转到PSRAM完整framebuffer的时间。对比传统的完整frame渲染后进行完整frame旋转再推屏的方式，会减少一定的时间开销。缺点是除了渲染用的硬件单元，还需要额外增加一个专门用于渲染的硬件。在调研中发现，一个GPU配合一个2D图像单元是很常见的组合，NXP有大量SoC采用了这种结构。