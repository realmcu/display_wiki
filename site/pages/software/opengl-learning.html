

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OpenGL 可编程管线学习笔记 &mdash; Display Wiki v0.1 文档</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/auto.number.title.css?v=161e9acd" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=faefd506" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=d7bb714b"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../_static/translations.js?v=beaddf03"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs"></script>
      <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.2.0/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
      <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
      <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.esm.min.mjs";

const defaultStyle = document.createElement('style');
defaultStyle.textContent = `pre.mermaid {
    /* Same as .mermaid-container > pre */
    display: block;
    width: 100%;
}

pre.mermaid > svg {
    /* Same as .mermaid-container > pre > svg */
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}
`;
document.head.appendChild(defaultStyle);

const fullscreenStyle = document.createElement('style');
fullscreenStyle.textContent = `.mermaid-container {
    display: flex;
    flex-direction: row;
    width: 100%;
}

.mermaid-container > pre {
    display: block;
    width: 100%;
}

.mermaid-container > pre > svg {
    height: 500px;
    width: 100%;
    max-width: 100% !important;
}

.mermaid-fullscreen-btn {
    width: 28px;
    height: 28px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    font-size: 14px;
    line-height: 1;
    padding: 0;
    color: #333;
}

.mermaid-fullscreen-btn:hover {
    opacity: 100% !important;
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
    transform: scale(1.1);
}

.mermaid-fullscreen-btn.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #e0e0e0;
}

.mermaid-fullscreen-btn.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 3px 10px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal {
    display: none;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 95vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.98);
    z-index: 9999;
    padding: 20px;
    overflow: auto;
}

.mermaid-fullscreen-modal.dark-theme {
    background: rgba(0, 0, 0, 0.98);
}

.mermaid-fullscreen-modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen {
    position: relative;
    width: 95vw;
    height: 90vh;
    max-width: 95vw;
    max-height: 90vh;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    overflow: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen.dark-theme {
    background: #1a1a1a;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
}

.mermaid-container-fullscreen pre.mermaid {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-container-fullscreen .mermaid svg {
    height: 100% !important;
    width: 100% !important;
    cursor: grab;
}

.mermaid-fullscreen-close {
    position: fixed !important;
    top: 20px !important;
    right: 20px !important;
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(0, 0, 0, 0.2);
    border-radius: 50%;
    cursor: pointer;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    transition: all 0.2s;
    font-size: 24px;
    line-height: 1;
    color: #333;
}

.mermaid-fullscreen-close:hover {
    background: white;
    box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
    transform: scale(1.1);
}

.mermaid-fullscreen-close.dark-theme {
    background: rgba(50, 50, 50, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #e0e0e0;
}

.mermaid-fullscreen-close.dark-theme:hover {
    background: rgba(60, 60, 60, 1);
    box-shadow: 0 6px 16px rgba(255, 255, 255, 0.2);
}

.mermaid-fullscreen-modal .mermaid-fullscreen-btn {
    display: none !important;
}`;
document.head.appendChild(fullscreenStyle);

// Detect if page has dark background
const isDarkTheme = () => {
    const bgColor = window.getComputedStyle(document.body).backgroundColor;
    const match = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
        return brightness < 128;
    }
    return false;
};

const load = async () => {
    await mermaid.run();

    const all_mermaids = document.querySelectorAll(".mermaid");
    const mermaids_processed = document.querySelectorAll(".mermaid[data-processed='true']");

    if ("False" === "True") {
        const mermaids_to_add_zoom = -1 === -1 ? all_mermaids.length : -1;
        if(mermaids_to_add_zoom > 0) {
            var svgs = d3.selectAll("");
            if(all_mermaids.length !== mermaids_processed.length) {
                setTimeout(load, 200);
                return;
            } else if(svgs.size() !== mermaids_to_add_zoom) {
                setTimeout(load, 200);
                return;
            } else {
                svgs.each(function() {
                    var svg = d3.select(this);
                    svg.html("<g class='wrapper'>" + svg.html() + "</g>");
                    var inner = svg.select("g");
                    var zoom = d3.zoom().on("zoom", function(event) {
                        inner.attr("transform", event.transform);
                    });
                    svg.call(zoom);
                });
            }
        }
    } else if(all_mermaids.length !== mermaids_processed.length) {
        // Wait for mermaid to process all diagrams
        setTimeout(load, 200);
        return;
    }

    const darkTheme = isDarkTheme();

    // Stop here if not adding fullscreen capability
    if ("True" !== "True") return;

    const modal = document.createElement('div');
    modal.className = 'mermaid-fullscreen-modal' + (darkTheme ? ' dark-theme' : '');
    modal.setAttribute('role', 'dialog');
    modal.setAttribute('aria-modal', 'true');
    modal.setAttribute('aria-label', 'Fullscreen diagram viewer');
    modal.innerHTML = `
        <button class="mermaid-fullscreen-close${darkTheme ? ' dark-theme' : ''}" aria-label="Close fullscreen">✕</button>
        <div class="mermaid-container-fullscreen${darkTheme ? ' dark-theme' : ''}"></div>
    `;
    document.body.appendChild(modal);

    const modalContent = modal.querySelector('.mermaid-container-fullscreen');
    const closeBtn = modal.querySelector('.mermaid-fullscreen-close');

    let previousScrollOffset = [window.scrollX, window.scrollY];

    const closeModal = () => {
        modal.classList.remove('active');
        modalContent.innerHTML = '';
        document.body.style.overflow = ''
        window.scrollTo({left: previousScrollOffset[0], top: previousScrollOffset[1], behavior: 'instant'});
    };

    closeBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeModal();
        }
    });

    const allButtons = [];

    document.querySelectorAll('.mermaid').forEach((mermaidDiv) => {
        if (mermaidDiv.parentNode.classList.contains('mermaid-container') ||
            mermaidDiv.closest('.mermaid-fullscreen-modal')) {
            return;
        }

        const container = document.createElement('div');
        container.className = 'mermaid-container';
        mermaidDiv.parentNode.insertBefore(container, mermaidDiv);
        container.appendChild(mermaidDiv);

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'mermaid-fullscreen-btn' + (darkTheme ? ' dark-theme' : '');
        fullscreenBtn.setAttribute('aria-label', 'View diagram in fullscreen');
        fullscreenBtn.textContent = '⛶';
        fullscreenBtn.style.opacity = '50%';

        // Calculate dynamic position based on diagram's margin and padding
        const diagramStyle = window.getComputedStyle(mermaidDiv);
        const marginTop = parseFloat(diagramStyle.marginTop) || 0;
        const marginRight = parseFloat(diagramStyle.marginRight) || 0;
        const paddingTop = parseFloat(diagramStyle.paddingTop) || 0;
        const paddingRight = parseFloat(diagramStyle.paddingRight) || 0;
        fullscreenBtn.style.top = `${marginTop + paddingTop + 4}px`;
        fullscreenBtn.style.right = `${marginRight + paddingRight + 4}px`;

        fullscreenBtn.addEventListener('click', () => {
            previousScrollOffset = [window.scroll, window.scrollY];
            const clone = mermaidDiv.cloneNode(true);
            modalContent.innerHTML = '';
            modalContent.appendChild(clone);

            const svg = clone.querySelector('svg');
            if (svg) {
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                svg.style.width = '100%';
                svg.style.height = 'auto';
                svg.style.maxWidth = '100%';
                svg.style.sdisplay = 'block';

                if ("False" === "True") {
                    setTimeout(() => {
                        const g = svg.querySelector('g');
                        if (g) {
                            var svgD3 = d3.select(svg);
                            svgD3.html("<g class='wrapper'>" + svgD3.html() + "</g>");
                            var inner = svgD3.select("g");
                            var zoom = d3.zoom().on("zoom", function(event) {
                                inner.attr("transform", event.transform);
                            });
                            svgD3.call(zoom);
                        }
                    }, 100);
                }
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        });

        container.appendChild(fullscreenBtn);
        allButtons.push(fullscreenBtn);
    });

    // Update theme classes when theme changes
    const updateTheme = () => {
        const dark = isDarkTheme();
        allButtons.forEach(btn => {
            if (dark) {
                btn.classList.add('dark-theme');
            } else {
                btn.classList.remove('dark-theme');
            }
        });
        if (dark) {
            modal.classList.add('dark-theme');
            modalContent.classList.add('dark-theme');
            closeBtn.classList.add('dark-theme');
        } else {
            modal.classList.remove('dark-theme');
            modalContent.classList.remove('dark-theme');
            closeBtn.classList.remove('dark-theme');
        }
    };

    // Watch for theme changes
    const observer = new MutationObserver(updateTheme);
    observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class', 'style', 'data-theme']
    });
    observer.observe(document.body, {
        attributes: true,
        attributeFilter: ['class', 'style']
    });
};

window.addEventListener("load", load);
</script>
      <script src="../../_static/js/pdf-viewer.js?v=a39b150e"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="矢量图形方案" href="vector.html" />
    <link rel="prev" title="视频方案" href="video.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quickstart/index.html">快速开始</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hardware/index.html">硬件平台</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">软件开发</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="map.html">地图方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="video.html">视频方案</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">OpenGL 可编程管线学习笔记</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">OpenGL 渲染流程总览</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">学习路线</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">第一步: 最简单的着色器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">什么是着色器？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vs">固定管线 vs 可编程管线</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">最简单的顶点着色器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">最简单的片段着色器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">着色器编译流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">完整示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">关键收获</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#uniform">第二步: Uniform 变量</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">什么是 Uniform？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">变量类型对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">使用流程</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id13">1. 在着色器中声明</a></li>
<li class="toctree-l5"><a class="reference internal" href="#cpu">2. 在 CPU 端获取位置</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id14">3. 设置值</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id15">示例: 动态旋转光源</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">Uniform 类型速查</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">完整示例: 带光照的三角形</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">关键收获</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id19">第三步: 自定义矩阵</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">为什么要自己实现矩阵？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">矩阵变换流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#perspective">1. 透视投影矩阵 (Perspective)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lookat">2. 视图矩阵 (LookAt)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#model">3. 模型矩阵 (Model)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">4. 矩阵乘法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id23">完整示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">着色器改动</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">关键收获</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vbo">第四步: VBO 顶点缓冲</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id26">为什么需要 VBO？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">数据流对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id28">实现步骤</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id29">1. 数据准备 - 展开面索引</a></li>
<li class="toctree-l5"><a class="reference internal" href="#vbo-gpu">2. 创建 VBO - 上传到 GPU</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id30">3. 渲染时使用 VBO</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#obj-vbo">完整示例: 加载 OBJ 并使用 VBO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id31">性能对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="#api">关键 API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id32">关键收获</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id33">第五步: 纹理映射</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id34">什么是纹理映射？</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id35">核心概念</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#texture">1. 纹理 (Texture)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#uv">2. UV 坐标</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id36">3. 纹理采样</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id37">工作流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id38">实现步骤</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id39">1. 生成程序纹理</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id40">2. 解析 UV 坐标</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id41">3. 创建纹理坐标 VBO</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id42">4. 修改着色器</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id43">5. 渲染时绑定纹理</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id44">完整示例: 带纹理的旋转立方体</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id45">纹理参数详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id46">关键 API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id47">关键收获</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id48">扩展: 加载真实图片纹理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#stb-image-h">使用 stb_image.h</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id49">1. 下载库文件</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id50">2. 集成到代码</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id51">3. 加载纹理函数</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id52">4. 使用示例</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id53">5. 支持的格式</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id54">6. 高级选项</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id55">对比总结</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id56">资源推荐</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id57">总结与进阶方向</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id58">你已经掌握的技能</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id59">完整渲染流程回顾</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id60">下一步进阶方向</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#opengl-3-0">1. 现代 OpenGL (3.0+)</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id61">2. 高级光照</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id62">3. 性能优化</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id63">4. 高级纹理</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id64">5. 几何处理</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id65">推荐学习资源</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id66">实践项目建议</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id67">附录</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id68">核心概念速查</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id69">着色器类型</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id70">变量类型</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id71">坐标变换</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id72">API 速查表</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id73">着色器相关</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id74">Uniform 相关</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id75">VBO 相关</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id76">纹理相关</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id77">OpenGL 函数命名规则</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id78">常见问题</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id79">代码文件说明</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="vector.html">矢量图形方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="glass.html">流体玻璃方案</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../applications/index.html">应用案例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">常见问题</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Display Wiki</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">软件开发</a></li>
      <li class="breadcrumb-item active">OpenGL 可编程管线学习笔记</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="opengl">
<h1>OpenGL 可编程管线学习笔记<a class="headerlink" href="#opengl" title="Link to this heading"></a></h1>
<section id="id1">
<h2>OpenGL 渲染流程总览<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<pre  class="mermaid">
        graph LR
    subgraph CPU[&quot;CPU 端准备&quot;]
        A[着色器编译]
        B[矩阵计算 MVP]
        C[VBO 上传顶点]
        D[纹理上传]
        E[Uniform 设置]
    end
    
    subgraph GPU[&quot;GPU 渲染管线&quot;]
        F[顶点着色器]
        G[光栅化插值]
        H[片段着色器]
        I[帧缓冲]
    end
    
    CPU --&gt; F
    F --&gt; G
    G --&gt; H
    H --&gt; I
    I --&gt; J[屏幕]
    
    style CPU fill:#ffe6e6
    style GPU fill:#e6f3ff
    style J fill:#fff4e6
    </pre><p><strong>数据流</strong>: CPU 准备数据 → GPU 顶点处理 → 光栅化 → 像素着色 → 屏幕显示</p>
<p><strong>5 个学习步骤对应</strong>:</p>
<ol class="arabic simple">
<li><p>着色器编译 (<code class="docutils literal notranslate"><span class="pre">glCompileShader</span></code>)</p></li>
<li><p>Uniform 设置 (<code class="docutils literal notranslate"><span class="pre">glUniform*</span></code>)</p></li>
<li><p>矩阵计算 (MVP = Projection × View × Model)</p></li>
<li><p>VBO 上传 (<code class="docutils literal notranslate"><span class="pre">glBufferData</span></code>)</p></li>
<li><p>纹理上传 (<code class="docutils literal notranslate"><span class="pre">glTexImage2D</span></code>)</p></li>
</ol>
</section>
<hr class="docutils" />
<section id="id2">
<h2>学习路线<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>步骤</p></th>
<th class="head"><p>主题</p></th>
<th class="head"><p>作用</p></th>
<th class="head"><p>状态</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>最简单的着色器</p></td>
<td><p>理解顶点和片段着色器的基本结构，实现从固定管线到可编程管线的转变</p></td>
<td><p>✅ 完成</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>Uniform 变量</p></td>
<td><p>学习从 CPU 向 GPU 传递参数(如矩阵、颜色、时间)，实现动态控制渲染效果</p></td>
<td><p>✅ 完成</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>自定义矩阵 (摆脱 gluPerspective)</p></td>
<td><p>掌握投影和变换矩阵的数学原理，完全控制 3D 空间到 2D 屏幕的映射</p></td>
<td><p>✅ 完成</p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p>VBO 顶点缓冲 (摆脱 glBegin/glEnd)</p></td>
<td><p>使用现代 GPU 缓冲机制，大幅提升渲染性能，支持大规模顶点数据</p></td>
<td><p>✅ 完成</p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p>纹理映射</p></td>
<td><p>为 3D 模型贴图，实现真实感渲染，学习纹理坐标和采样器的使用</p></td>
<td><p>✅ 完成</p></td>
</tr>
</tbody>
</table>
</section>
<hr class="docutils" />
<section id="id3">
<h2>第一步: 最简单的着色器<a class="headerlink" href="#id3" title="Link to this heading"></a></h2>
<section id="id4">
<h3>什么是着色器？<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>着色器是运行在 GPU 上的小程序，用于控制顶点和像素的处理。</p>
</section>
<section id="vs">
<h3>固定管线 vs 可编程管线<a class="headerlink" href="#vs" title="Link to this heading"></a></h3>
<p><strong>固定管线</strong> (OpenGL 1.x):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>glVertex3fv() ──→ [GPU内部固定算法] ──→ 屏幕像素
                  (你无法修改)
</pre></div>
</div>
<p><strong>可编程管线</strong> (OpenGL 2.0+):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>glVertex3fv() ──→ [你写的着色器代码] ──→ 屏幕像素
                  (完全可控)
</pre></div>
</div>
</section>
<section id="id5">
<h3>最简单的顶点着色器<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 将顶点从模型空间变换到裁剪空间</span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">gl_ModelViewProjectionMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_Vertex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>输入</strong>: <code class="docutils literal notranslate"><span class="pre">gl_Vertex</span></code> (顶点位置)<br />
<strong>输出</strong>: <code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> (裁剪空间坐标)</p>
</section>
<section id="id6">
<h3>最简单的片段着色器<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 为每个像素设置固定颜色 (橙色)</span>
<span class="w">    </span><span class="nb">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>输出</strong>: <code class="docutils literal notranslate"><span class="pre">gl_FragColor</span></code> (RGBA 颜色)</p>
</section>
<section id="id7">
<h3>着色器编译流程<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 顶点着色器源代码</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">vertex_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;void main() {&quot;</span>
<span class="w">    </span><span class="s">&quot;    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;&quot;</span>
<span class="w">    </span><span class="s">&quot;}&quot;</span><span class="p">;</span>

<span class="c1">// 片段着色器源代码</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fragment_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;void main() {&quot;</span>
<span class="w">    </span><span class="s">&quot;    gl_FragColor = vec4(1.0, 0.5, 0.2, 1.0);&quot;</span>
<span class="w">    </span><span class="s">&quot;}&quot;</span><span class="p">;</span>

<span class="c1">// 1. 创建着色器对象</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_VERTEX_SHADER</span><span class="p">);</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">fs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateShader</span><span class="p">(</span><span class="n">GL_FRAGMENT_SHADER</span><span class="p">);</span>

<span class="c1">// 2. 设置源代码</span>
<span class="n">glShaderSource</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vertex_src</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="n">glShaderSource</span><span class="p">(</span><span class="n">fs</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fragment_src</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// 3. 编译</span>
<span class="n">glCompileShader</span><span class="p">(</span><span class="n">vs</span><span class="p">);</span>
<span class="n">glCompileShader</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>

<span class="c1">// 4. 检查编译错误 (可选但推荐)</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">success</span><span class="p">;</span>
<span class="n">glGetShaderiv</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span><span class="w"> </span><span class="n">GL_COMPILE_STATUS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">log</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="w">    </span><span class="n">glGetShaderInfoLog</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">);</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Vertex shader compilation failed: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 5. 创建程序并链接</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glCreateProgram</span><span class="p">();</span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">vs</span><span class="p">);</span>
<span class="n">glAttachShader</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">fs</span><span class="p">);</span>
<span class="n">glLinkProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>

<span class="c1">// 6. 检查链接错误</span>
<span class="n">glGetProgramiv</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINK_STATUS</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">success</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">log</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="w">    </span><span class="n">glGetProgramInfoLog</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">);</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Program linking failed: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 7. 使用着色器程序</span>
<span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>

<span class="c1">// 8. 清理 (着色器对象可以删除，程序对象保留)</span>
<span class="n">glDeleteShader</span><span class="p">(</span><span class="n">vs</span><span class="p">);</span>
<span class="n">glDeleteShader</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="id8">
<h3>完整示例<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">render</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 使用着色器程序</span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 绘制三角形 (使用立即模式演示)</span>
<span class="w">    </span><span class="n">glBegin</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertex3f</span><span class="p">(</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertex3f</span><span class="p">(</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertex3f</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glEnd</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id9">
<h3>关键收获<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>✅ 理解顶点着色器和片段着色器的分工</p></li>
<li><p>✅ 掌握着色器编译和链接流程</p></li>
<li><p>✅ 从固定管线过渡到可编程管线</p></li>
<li><p>✅ 学会检查编译和链接错误</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="uniform">
<h2>第二步: Uniform 变量<a class="headerlink" href="#uniform" title="Link to this heading"></a></h2>
<section id="id10">
<h3>什么是 Uniform？<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p>Uniform 是从 CPU 传递给 GPU 的全局变量，在一次绘制调用中对所有顶点和像素保持不变。</p>
</section>
<section id="id11">
<h3>变量类型对比<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>类型</p></th>
<th class="head"><p>来源</p></th>
<th class="head"><p>特点</p></th>
<th class="head"><p>示例</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Attribute</strong></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">glVertex*()</span></code></p></td>
<td><p>每个顶点不同</p></td>
<td><p>位置、法线、UV</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Uniform</strong></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">glUniform*()</span></code></p></td>
<td><p>全局共享</p></td>
<td><p>矩阵、光源、时间</p></td>
</tr>
<tr class="row-even"><td><p><strong>Varying</strong></p></td>
<td><p>顶点着色器输出</p></td>
<td><p>GPU 自动插值</p></td>
<td><p>传递法线、颜色</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id12">
<h3>使用流程<a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<section id="id13">
<h4>1. 在着色器中声明<a class="headerlink" href="#id13" title="Link to this heading"></a></h4>
<p><strong>顶点着色器</strong>:</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">uMVP</span><span class="p">;</span><span class="w">  </span><span class="c1">// 模型视图投影矩阵</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uMVP</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_Vertex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>片段着色器</strong>:</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">uLightDir</span><span class="p">;</span><span class="w">  </span><span class="c1">// 光源方向</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">uColor</span><span class="p">;</span><span class="w">     </span><span class="c1">// 物体颜色</span>

<span class="k">varying</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">vNormal</span><span class="p">;</span><span class="w">    </span><span class="c1">// 从顶点着色器传来的法线</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">vNormal</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">uLightDir</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 漫反射</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">0.2</span><span class="p">);</span><span class="w">  </span><span class="c1">// 环境光</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lighting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="nb">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">uColor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lighting</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="cpu">
<h4>2. 在 CPU 端获取位置<a class="headerlink" href="#cpu" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">program</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* 已编译链接的程序 */</span><span class="p">;</span>

<span class="c1">// 获取 Uniform 变量的位置</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">loc_mvp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;uMVP&quot;</span><span class="p">);</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">loc_light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;uLightDir&quot;</span><span class="p">);</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">loc_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;uColor&quot;</span><span class="p">);</span>

<span class="c1">// 检查是否找到</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">loc_mvp</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Warning: uniform &#39;uMVP&#39; not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id14">
<h4>3. 设置值<a class="headerlink" href="#id14" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">render</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置矩阵 (4x4 float 矩阵)</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">mvp</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* ... */</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">loc_mvp</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">mvp</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置光源方向 (vec3)</span>
<span class="w">    </span><span class="n">glUniform3f</span><span class="p">(</span><span class="n">loc_light</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置颜色 (vec3)</span>
<span class="w">    </span><span class="n">glUniform3f</span><span class="p">(</span><span class="n">loc_color</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 绘制...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id15">
<h3>示例: 动态旋转光源<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">GLint</span><span class="w"> </span><span class="n">g_loc_light</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">g_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 编译着色器...</span>
<span class="w">    </span><span class="n">g_loc_light</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;uLightDir&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">render</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 光源绕 Y 轴旋转</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_frame</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">lx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cosf</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">lz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">glUniform3f</span><span class="p">(</span><span class="n">g_loc_light</span><span class="p">,</span><span class="w"> </span><span class="n">lx</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="n">lz</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 绘制模型...</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">g_frame</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id16">
<h3>Uniform 类型速查<a class="headerlink" href="#id16" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>函数</p></th>
<th class="head"><p>GLSL 类型</p></th>
<th class="head"><p>参数</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glUniform1f(loc,</span> <span class="pre">v)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">float</span></code></p></td>
<td><p>1 个 float</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glUniform2f(loc,</span> <span class="pre">x,</span> <span class="pre">y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">vec2</span></code></p></td>
<td><p>2 个 float</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glUniform3f(loc,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">vec3</span></code></p></td>
<td><p>3 个 float</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glUniform4f(loc,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">w)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">vec4</span></code></p></td>
<td><p>4 个 float</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glUniform1i(loc,</span> <span class="pre">v)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">int</span></code> / <code class="docutils literal notranslate"><span class="pre">sampler2D</span></code></p></td>
<td><p>1 个 int</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glUniformMatrix4fv(loc,</span> <span class="pre">n,</span> <span class="pre">transpose,</span> <span class="pre">m)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">mat4</span></code></p></td>
<td><p>4x4 矩阵</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id17">
<h3>完整示例: 带光照的三角形<a class="headerlink" href="#id17" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 顶点着色器</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">vs_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;uniform mat4 uMVP;&quot;</span>
<span class="w">    </span><span class="s">&quot;varying vec3 vNormal;&quot;</span>
<span class="w">    </span><span class="s">&quot;void main() {&quot;</span>
<span class="w">    </span><span class="s">&quot;    gl_Position = uMVP * gl_Vertex;&quot;</span>
<span class="w">    </span><span class="s">&quot;    vNormal = gl_NormalMatrix * gl_Normal;&quot;</span>
<span class="w">    </span><span class="s">&quot;}&quot;</span><span class="p">;</span>

<span class="c1">// 片段着色器</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fs_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="s">&quot;uniform vec3 uLightDir;&quot;</span>
<span class="w">    </span><span class="s">&quot;varying vec3 vNormal;&quot;</span>
<span class="w">    </span><span class="s">&quot;void main() {&quot;</span>
<span class="w">    </span><span class="s">&quot;    vec3 N = normalize(vNormal);&quot;</span>
<span class="w">    </span><span class="s">&quot;    vec3 L = normalize(uLightDir);&quot;</span>
<span class="w">    </span><span class="s">&quot;    float diff = max(dot(N, L), 0.0);&quot;</span>
<span class="w">    </span><span class="s">&quot;    vec3 color = vec3(1.0, 0.5, 0.2) * (0.2 + diff);&quot;</span>
<span class="w">    </span><span class="s">&quot;    gl_FragColor = vec4(color, 1.0);&quot;</span>
<span class="w">    </span><span class="s">&quot;}&quot;</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">render</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置 MVP 矩阵</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">mvp</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="w">    </span><span class="n">glGetFloatv</span><span class="p">(</span><span class="n">GL_MODELVIEW_PROJECTION_MATRIX</span><span class="p">,</span><span class="w"> </span><span class="n">mvp</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">loc_mvp</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">mvp</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置光源</span>
<span class="w">    </span><span class="n">glUniform3f</span><span class="p">(</span><span class="n">loc_light</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 绘制</span>
<span class="w">    </span><span class="n">glBegin</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">);</span>
<span class="w">    </span><span class="n">glNormal3f</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertex3f</span><span class="p">(</span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertex3f</span><span class="p">(</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertex3f</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">glEnd</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id18">
<h3>关键收获<a class="headerlink" href="#id18" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>✅ 理解 CPU 和 GPU 的数据传递机制</p></li>
<li><p>✅ 掌握 Uniform 变量的声明、获取和设置</p></li>
<li><p>✅ 实现动态光照效果</p></li>
<li><p>✅ 理解 Attribute、Uniform、Varying 的区别</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="id19">
<h2>第三步: 自定义矩阵<a class="headerlink" href="#id19" title="Link to this heading"></a></h2>
<section id="id20">
<h3>为什么要自己实现矩阵？<a class="headerlink" href="#id20" title="Link to this heading"></a></h3>
<p><strong>固定管线函数的问题</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gluPerspective</span></code> / <code class="docutils literal notranslate"><span class="pre">gluLookAt</span></code> 是固定管线遗留 API</p></li>
<li><p>现代 OpenGL (3.0+) 已废弃这些函数</p></li>
<li><p>不理解数学原理，无法灵活控制</p></li>
</ul>
</section>
<section id="id21">
<h3>矩阵变换流程<a class="headerlink" href="#id21" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>顶点坐标变换:
  模型空间 ──Model──→ 世界空间 ──View──→ 相机空间 ──Projection──→ 裁剪空间
  (0,0,0)            (场景中心)        (相机视角)          (屏幕坐标)

MVP 矩阵 = Projection × View × Model
</pre></div>
</div>
</section>
<section id="perspective">
<h3>1. 透视投影矩阵 (Perspective)<a class="headerlink" href="#perspective" title="Link to this heading"></a></h3>
<p><strong>作用</strong>: 实现&quot;近大远小&quot;的透视效果</p>
<p><strong>数学公式</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>f = 1 / tan(fov_y / 2)

┌                                          ┐
│ f/aspect    0         0            0     │
│    0        f         0            0     │
│    0        0   -(f+n)/(f-n)  -2fn/(f-n) │
│    0        0        -1            0     │
└                                          ┘
</pre></div>
</div>
<p><strong>参数</strong>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fov_y</span></code>: 垂直视野角度 (如 45°)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">aspect</span></code>: 宽高比 (width / height)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">near</span></code>: 近裁剪面 (如 0.1)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">far</span></code>: 远裁剪面 (如 100.0)</p></li>
</ul>
<p><strong>代码实现</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">mat4</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w">  </span><span class="c1">// 列主序存储</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">mat4_perspective</span><span class="p">(</span><span class="n">mat4</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fov_y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">aspect</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">far</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">tanf</span><span class="p">(</span><span class="n">fov_y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">mat4</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">aspect</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">far</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">near</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">far</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">near</span><span class="p">);</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="mf">2.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">near</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">far</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">near</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="lookat">
<h3>2. 视图矩阵 (LookAt)<a class="headerlink" href="#lookat" title="Link to this heading"></a></h3>
<p><strong>作用</strong>: 定义相机的位置和朝向</p>
<p><strong>数学原理</strong>:</p>
<ol class="arabic simple">
<li><p>计算相机坐标系的三个轴</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">forward</span> <span class="pre">=</span> <span class="pre">normalize(center</span> <span class="pre">-</span> <span class="pre">eye)</span></code> (相机朝向)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">right</span> <span class="pre">=</span> <span class="pre">normalize(forward</span> <span class="pre">×</span> <span class="pre">up)</span></code> (相机右向)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">up'</span> <span class="pre">=</span> <span class="pre">right</span> <span class="pre">×</span> <span class="pre">forward</span></code> (相机上向)</p></li>
</ul>
</li>
<li><p>构建旋转 + 平移矩阵</p></li>
</ol>
<p><strong>代码实现</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 向量归一化</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrtf</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">    </span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 向量点积</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">dot</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">mat4_look_at</span><span class="p">(</span><span class="n">mat4</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">eye</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">center</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 计算 forward 向量</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">eye</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="w">        </span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">eye</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="w">        </span><span class="n">center</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">eye</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">normalize</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// right = forward × up</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="w">        </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
<span class="w">        </span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">normalize</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// up&#39; = right × forward</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="w">        </span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
<span class="w">        </span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 构建矩阵 (旋转 + 平移)</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">mat4</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">  </span><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">  </span><span class="n">m</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w">  </span><span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w">  </span><span class="n">m</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="p">);</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="model">
<h3>3. 模型矩阵 (Model)<a class="headerlink" href="#model" title="Link to this heading"></a></h3>
<p><strong>旋转矩阵</strong> (绕任意轴):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mat4_rotate</span><span class="p">(</span><span class="n">mat4</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 归一化旋转轴</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrtf</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cosf</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sinf</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Rodrigues 旋转公式</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">mat4</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">     </span><span class="n">m</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">z</span><span class="p">;</span><span class="w">   </span><span class="n">m</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">z</span><span class="p">;</span><span class="w">   </span><span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">     </span><span class="n">m</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">y</span><span class="p">;</span><span class="w">   </span><span class="n">m</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="o">*</span><span class="n">x</span><span class="p">;</span><span class="w">   </span><span class="n">m</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="o">*</span><span class="n">z</span><span class="o">*</span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>单位矩阵</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mat4_identity</span><span class="p">(</span><span class="n">mat4</span><span class="w"> </span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">mat4</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id22">
<h3>4. 矩阵乘法<a class="headerlink" href="#id22" title="Link to this heading"></a></h3>
<p><strong>注意</strong>: OpenGL 使用<strong>列主序</strong>存储</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mat4_multiply</span><span class="p">(</span><span class="n">mat4</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">mat4</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">];</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">mat4</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id23">
<h3>完整示例<a class="headerlink" href="#id23" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">mat4</span><span class="w"> </span><span class="n">g_proj</span><span class="p">,</span><span class="w"> </span><span class="n">g_view</span><span class="p">,</span><span class="w"> </span><span class="n">g_model</span><span class="p">,</span><span class="w"> </span><span class="n">g_mvp</span><span class="p">;</span>
<span class="n">GLint</span><span class="w"> </span><span class="n">g_loc_mvp</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">g_angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 编译着色器...</span>
<span class="w">    </span><span class="n">g_loc_mvp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;uMVP&quot;</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 构建投影矩阵 (只需初始化一次)</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">aspect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">height</span><span class="p">;</span>
<span class="w">    </span><span class="n">mat4_perspective</span><span class="p">(</span><span class="n">g_proj</span><span class="p">,</span><span class="w"> </span><span class="mf">45.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">180.0f</span><span class="p">,</span><span class="w"> </span><span class="n">aspect</span><span class="p">,</span><span class="w"> </span><span class="mf">0.1f</span><span class="p">,</span><span class="w"> </span><span class="mf">100.0f</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 构建视图矩阵 (相机位置)</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">eye</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">};</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">center</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="n">mat4_look_at</span><span class="p">(</span><span class="n">g_view</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="p">,</span><span class="w"> </span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="n">up</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">render</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 构建模型矩阵 (每帧旋转)</span>
<span class="w">    </span><span class="n">mat4_rotate</span><span class="p">(</span><span class="n">g_model</span><span class="p">,</span><span class="w"> </span><span class="n">g_angle</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">g_angle</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.01f</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 组合 MVP = Projection × View × Model</span>
<span class="w">    </span><span class="n">mat4</span><span class="w"> </span><span class="n">modelview</span><span class="p">;</span>
<span class="w">    </span><span class="n">mat4_multiply</span><span class="p">(</span><span class="n">modelview</span><span class="p">,</span><span class="w"> </span><span class="n">g_view</span><span class="p">,</span><span class="w"> </span><span class="n">g_model</span><span class="p">);</span>
<span class="w">    </span><span class="n">mat4_multiply</span><span class="p">(</span><span class="n">g_mvp</span><span class="p">,</span><span class="w"> </span><span class="n">g_proj</span><span class="p">,</span><span class="w"> </span><span class="n">modelview</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 传递给着色器</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">g_loc_mvp</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">g_mvp</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 绘制...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id24">
<h3>着色器改动<a class="headerlink" href="#id24" title="Link to this heading"></a></h3>
<p><strong>旧版</strong> (使用固定管线):</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">gl_ModelViewProjectionMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_Vertex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>新版</strong> (使用自定义 Uniform):</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">uMVP</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uMVP</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_Vertex</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id25">
<h3>关键收获<a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>✅ 理解坐标变换: 模型空间 → 世界空间 → 相机空间 → 裁剪空间</p></li>
<li><p>✅ 掌握投影、视图、旋转矩阵的构建</p></li>
<li><p>✅ 理解矩阵乘法和列主序存储</p></li>
<li><p>✅ 摆脱固定管线函数，完全控制变换</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="vbo">
<h2>第四步: VBO 顶点缓冲<a class="headerlink" href="#vbo" title="Link to this heading"></a></h2>
<section id="id26">
<h3>为什么需要 VBO？<a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
<p><strong>立即模式的问题</strong> (glBegin/glEnd):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 每帧都要执行，740 个顶点 = 2220 次函数调用</span>
<span class="n">glBegin</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">740</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">glNormal3fv</span><span class="p">(...);</span><span class="w">   </span><span class="c1">// CPU → GPU</span>
<span class="w">    </span><span class="n">glVertex3fv</span><span class="p">(...);</span><span class="w">   </span><span class="c1">// CPU → GPU</span>
<span class="w">    </span><span class="n">glVertex3fv</span><span class="p">(...);</span><span class="w">   </span><span class="c1">// CPU → GPU</span>
<span class="p">}</span>
<span class="n">glEnd</span><span class="p">();</span>
</pre></div>
</div>
<ul class="simple">
<li><p>❌ 每帧从 CPU 传输数据到 GPU</p></li>
<li><p>❌ 函数调用开销巨大</p></li>
<li><p>❌ 数据在 CPU 内存，GPU 访问慢</p></li>
<li><p>❌ OpenGL 3.0+ 已废弃</p></li>
</ul>
<p><strong>VBO 的优势</strong>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 初始化时执行一次</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vbo</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>

<span class="c1">// 每帧只需一次调用</span>
<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">vertex_count</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>✅ 数据存储在 GPU 显存</p></li>
<li><p>✅ 只上传一次，重复使用</p></li>
<li><p>✅ 一次调用绘制所有顶点</p></li>
<li><p>✅ 现代 OpenGL 标准</p></li>
</ul>
</section>
<section id="id27">
<h3>数据流对比<a class="headerlink" href="#id27" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>立即模式:
  CPU 内存 ──每帧──→ GPU
  (慢，重复传输)

VBO 模式:
  CPU 内存 ──初始化──→ GPU 显存
                        ↓
                   每帧直接读取
  (快，零拷贝)
</pre></div>
</div>
</section>
<section id="id28">
<h3>实现步骤<a class="headerlink" href="#id28" title="Link to this heading"></a></h3>
<section id="id29">
<h4>1. 数据准备 - 展开面索引<a class="headerlink" href="#id29" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// OBJ 文件数据</span>
<span class="kt">float</span><span class="w"> </span><span class="n">vertices</span><span class="p">[</span><span class="mi">740</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span><span class="w">  </span><span class="c1">// 740 个顶点</span>
<span class="kt">int</span><span class="w"> </span><span class="n">faces</span><span class="p">[</span><span class="mi">1476</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span><span class="w">      </span><span class="c1">// 1476 个三角形</span>

<span class="c1">// 展开为顶点数组 (每个三角形 3 个顶点)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">total_vertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">face_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">  </span><span class="c1">// 1476 * 3 = 4428</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">total_vertices</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">normals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">total_vertices</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>

<span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">face_count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">v_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span>
<span class="w">        </span><span class="c1">// 复制顶点位置</span>
<span class="w">        </span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertices</span><span class="p">[</span><span class="n">v_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertices</span><span class="p">[</span><span class="n">v_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vertices</span><span class="p">[</span><span class="n">v_idx</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
<span class="w">        </span>
<span class="w">        </span><span class="c1">// 复制法线 (面法线，三个顶点共享)</span>
<span class="w">        </span><span class="n">normals</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">face_normals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">normals</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">face_normals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">normals</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">face_normals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
<span class="w">        </span>
<span class="w">        </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="vbo-gpu">
<h4>2. 创建 VBO - 上传到 GPU<a class="headerlink" href="#vbo-gpu" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">vbo_position</span><span class="p">,</span><span class="w"> </span><span class="n">vbo_normal</span><span class="p">;</span>

<span class="c1">// 创建位置 VBO</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vbo_position</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vbo_position</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">             </span><span class="n">total_vertices</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
<span class="w">             </span><span class="n">positions</span><span class="p">,</span><span class="w"> </span>
<span class="w">             </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span><span class="w">  </span><span class="c1">// 静态数据，不会修改</span>

<span class="c1">// 创建法线 VBO</span>
<span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vbo_normal</span><span class="p">);</span>
<span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vbo_normal</span><span class="p">);</span>
<span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">             </span><span class="n">total_vertices</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
<span class="w">             </span><span class="n">normals</span><span class="p">,</span><span class="w"> </span>
<span class="w">             </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>

<span class="c1">// 上传后可以释放 CPU 内存</span>
<span class="n">free</span><span class="p">(</span><span class="n">positions</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">normals</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="id30">
<h4>3. 渲染时使用 VBO<a class="headerlink" href="#id30" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">render</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置 Uniform...</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 启用顶点属性数组</span>
<span class="w">    </span><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span>
<span class="w">    </span><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_NORMAL_ARRAY</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 绑定位置 VBO 并指定数据格式</span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vbo_position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertexPointer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 3 个分量，float 类型，无间隔</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 绑定法线 VBO</span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vbo_normal</span><span class="p">);</span>
<span class="w">    </span><span class="n">glNormalPointer</span><span class="p">(</span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 一次调用绘制所有顶点</span>
<span class="w">    </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">total_vertices</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 清理</span>
<span class="w">    </span><span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span>
<span class="w">    </span><span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_NORMAL_ARRAY</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="obj-vbo">
<h3>完整示例: 加载 OBJ 并使用 VBO<a class="headerlink" href="#obj-vbo" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 全局变量</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">g_vbo_position</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_normal</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">g_vertex_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">load_obj_and_create_vbo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. 读取 OBJ 文件</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">vertices</span><span class="p">[</span><span class="mi">10000</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">normals</span><span class="p">[</span><span class="mi">10000</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">faces</span><span class="p">[</span><span class="mi">10000</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">vertex_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">normal_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">face_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">FILE</span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">line</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;v&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39; &#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;v %f %f %f&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">                   </span><span class="o">&amp;</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex_count</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
<span class="w">                   </span><span class="o">&amp;</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex_count</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
<span class="w">                   </span><span class="o">&amp;</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex_count</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">            </span><span class="n">vertex_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;v&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;n&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vn %f %f %f&quot;</span><span class="p">,</span>
<span class="w">                   </span><span class="o">&amp;</span><span class="n">normals</span><span class="p">[</span><span class="n">normal_count</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
<span class="w">                   </span><span class="o">&amp;</span><span class="n">normals</span><span class="p">[</span><span class="n">normal_count</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
<span class="w">                   </span><span class="o">&amp;</span><span class="n">normals</span><span class="p">[</span><span class="n">normal_count</span><span class="p">][</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">            </span><span class="n">normal_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;f&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="n">n3</span><span class="p">;</span>
<span class="w">            </span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;f %d//%d %d//%d %d//%d&quot;</span><span class="p">,</span>
<span class="w">                   </span><span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n3</span><span class="p">);</span>
<span class="w">            </span><span class="n">faces</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="n">faces</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="n">faces</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="n">face_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 2. 展开数据</span>
<span class="w">    </span><span class="n">g_vertex_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">face_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">positions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">g_vertex_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">normals_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">g_vertex_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">face_count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">v_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">faces</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="w">            </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">positions</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">vertices</span><span class="p">[</span><span class="n">v_idx</span><span class="p">],</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">            </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">normals_data</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">normals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">            </span><span class="n">idx</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 3. 创建 VBO</span>
<span class="w">    </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_vbo_position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vertex_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
<span class="w">                 </span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_vbo_normal</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_normal</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vertex_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
<span class="w">                 </span><span class="n">normals_data</span><span class="p">,</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">positions</span><span class="p">);</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">normals_data</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Loaded %d vertices from %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">g_vertex_count</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">render</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置 MVP 矩阵...</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">loc_mvp</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="n">mvp</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 使用 VBO 绘制</span>
<span class="w">    </span><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span>
<span class="w">    </span><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_NORMAL_ARRAY</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertexPointer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_normal</span><span class="p">);</span>
<span class="w">    </span><span class="n">glNormalPointer</span><span class="p">(</span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">g_vertex_count</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span>
<span class="w">    </span><span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_NORMAL_ARRAY</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id31">
<h3>性能对比<a class="headerlink" href="#id31" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>方式</p></th>
<th class="head"><p>函数调用/帧</p></th>
<th class="head"><p>数据传输</p></th>
<th class="head"><p>性能</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>glBegin/glEnd</p></td>
<td><p>2220 次</p></td>
<td><p>每帧传输</p></td>
<td><p>慢 ⚠️</p></td>
</tr>
<tr class="row-odd"><td><p>VBO</p></td>
<td><p>1 次</p></td>
<td><p>初始化时传输一次</p></td>
<td><p>快 ✅</p></td>
</tr>
</tbody>
</table>
<p><strong>实测效果</strong> (740 顶点模型):</p>
<ul class="simple">
<li><p>立即模式: ~2220 次 CPU→GPU 调用/帧</p></li>
<li><p>VBO 模式: ~1 次 GPU 内部调用/帧</p></li>
</ul>
</section>
<section id="api">
<h3>关键 API<a class="headerlink" href="#api" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>函数</p></th>
<th class="head"><p>作用</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glGenBuffers(n,</span> <span class="pre">&amp;id)</span></code></p></td>
<td><p>创建 VBO</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glBindBuffer(target,</span> <span class="pre">id)</span></code></p></td>
<td><p>绑定 VBO</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glBufferData(target,</span> <span class="pre">size,</span> <span class="pre">data,</span> <span class="pre">usage)</span></code></p></td>
<td><p>上传数据</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glVertexPointer(size,</span> <span class="pre">type,</span> <span class="pre">stride,</span> <span class="pre">ptr)</span></code></p></td>
<td><p>指定顶点格式</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glNormalPointer(type,</span> <span class="pre">stride,</span> <span class="pre">ptr)</span></code></p></td>
<td><p>指定法线格式</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glDrawArrays(mode,</span> <span class="pre">first,</span> <span class="pre">count)</span></code></p></td>
<td><p>绘制</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id32">
<h3>关键收获<a class="headerlink" href="#id32" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>✅ 理解 VBO 的性能优势</p></li>
<li><p>✅ 掌握数据展开和上传流程</p></li>
<li><p>✅ 摆脱立即模式，使用现代 GPU 缓冲</p></li>
<li><p>✅ 实现高效的大规模顶点渲染</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="id33">
<h2>第五步: 纹理映射<a class="headerlink" href="#id33" title="Link to this heading"></a></h2>
<section id="id34">
<h3>什么是纹理映射？<a class="headerlink" href="#id34" title="Link to this heading"></a></h3>
<p><strong>类比</strong>: 给 3D 模型&quot;贴壁纸&quot;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">3</span><span class="n">D</span> <span class="n">模型</span> <span class="o">+</span> <span class="mi">2</span><span class="n">D</span> <span class="n">图片</span> <span class="o">=</span> <span class="n">带纹理的模型</span>
  <span class="n">茶壶</span>     <span class="n">木纹图</span>     <span class="n">木质茶壶</span>
</pre></div>
</div>
</section>
<section id="id35">
<h3>核心概念<a class="headerlink" href="#id35" title="Link to this heading"></a></h3>
<section id="texture">
<h4>1. 纹理 (Texture)<a class="headerlink" href="#texture" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>一张存储在 GPU 的图片（像素数组）</p></li>
<li><p>可以是照片、程序生成的图案、法线贴图等</p></li>
</ul>
</section>
<section id="uv">
<h4>2. UV 坐标<a class="headerlink" href="#uv" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>每个顶点附带的 2D 坐标 (u, v)</p></li>
<li><p>范围 [0, 1]，映射到纹理图片</p></li>
<li><p>(0, 0) = 左下角，(1, 1) = 右上角</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>纹理图片:
  (0,1) ────────── (1,1)
    │               │
    │   图片内容     │
    │               │
  (0,0) ────────── (1,0)
</pre></div>
</div>
</section>
<section id="id36">
<h4>3. 纹理采样<a class="headerlink" href="#id36" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>根据 UV 坐标从纹理中取颜色</p></li>
<li><p>GPU 自动插值：三角形内部的 UV 会平滑过渡</p></li>
</ul>
</section>
</section>
<section id="id37">
<h3>工作流程<a class="headerlink" href="#id37" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. CPU 准备数据
   ├─ 纹理图片: 256x256 像素数组
   └─ UV 坐标: 每个顶点的 (u, v) 值

2. 上传到 GPU
   ├─ glTexImage2D() → 图片存入显存
   └─ VBO → UV 坐标存入显存

3. 顶点着色器 (每个顶点)
   输入: 顶点位置 + UV 坐标
   输出: UV 坐标传递给片段着色器

4. 光栅化 (GPU 自动)
   三角形内部的 UV 自动插值
   例: 顶点 UV 为 (0,0) (1,0) (0,1)
       中心像素 UV 自动为 (0.33, 0.33)

5. 片段着色器 (每个像素)
   texture2D(纹理, UV) → 从图片采样颜色
   例: UV=(0.5, 0.5) → 取图片中心的颜色
</pre></div>
</div>
</section>
<section id="id38">
<h3>实现步骤<a class="headerlink" href="#id38" title="Link to this heading"></a></h3>
<section id="id39">
<h4>1. 生成程序纹理<a class="headerlink" href="#id39" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">g_texture</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">create_checkerboard_texture</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">256</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">grid_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">height</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="n">x</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">checker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grid_size</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">grid_size</span><span class="p">))</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">checker</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">255</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w">  </span><span class="c1">// 白色或深灰</span>
<span class="w">            </span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w">  </span><span class="c1">// R</span>
<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w">  </span><span class="c1">// G</span>
<span class="w">            </span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">color</span><span class="p">;</span><span class="w">  </span><span class="c1">// B</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 创建纹理对象</span>
<span class="w">    </span><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_texture</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">g_texture</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 上传数据到 GPU</span>
<span class="w">    </span><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span>
<span class="w">                 </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置过滤模式</span>
<span class="w">    </span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINEAR</span><span class="p">);</span>
<span class="w">    </span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINEAR</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置包裹模式</span>
<span class="w">    </span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span><span class="w"> </span><span class="n">GL_REPEAT</span><span class="p">);</span>
<span class="w">    </span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span><span class="w"> </span><span class="n">GL_REPEAT</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>优点</strong>:</p>
<ul class="simple">
<li><p>✅ 无外部文件依赖</p></li>
<li><p>✅ 代码自包含</p></li>
<li><p>✅ 棋盘格规律明显，便于调试</p></li>
</ul>
</section>
<section id="id40">
<h4>2. 解析 UV 坐标<a class="headerlink" href="#id40" title="Link to this heading"></a></h4>
<p>修改 OBJ 加载函数:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">texcoords</span><span class="p">[</span><span class="mi">10000</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">faces_tex</span><span class="p">[</span><span class="mi">10000</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">texcoord_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// 读取纹理坐标</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;vt %f %f&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">texcoords</span><span class="p">[</span><span class="n">texcoord_count</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>
<span class="w">    </span><span class="n">texcoords</span><span class="p">[</span><span class="n">texcoord_count</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">    </span><span class="n">texcoord_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 读取面（包含纹理索引）</span>
<span class="c1">// 格式: f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;f %d/%d/%d %d/%d/%d %d/%d/%d&quot;</span><span class="p">,</span>
<span class="w">           </span><span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vt1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vt2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn2</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v3</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vt3</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vn3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">faces</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">faces</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">faces</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">faces_tex</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vt1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">faces_tex</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vt2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">faces_tex</span><span class="p">[</span><span class="n">face_count</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vt3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">face_count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id41">
<h4>3. 创建纹理坐标 VBO<a class="headerlink" href="#id41" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="n">g_vbo_texcoord</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">create_texture_vbo</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 展开纹理坐标</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">texcoords_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="n">total_vertices</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">face_count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">vt_idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">faces_tex</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="w">            </span><span class="n">texcoords_data</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texcoords</span><span class="p">[</span><span class="n">vt_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
<span class="w">            </span><span class="n">texcoords_data</span><span class="p">[</span><span class="n">idx</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texcoords</span><span class="p">[</span><span class="n">vt_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 创建 VBO</span>
<span class="w">    </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">g_vbo_texcoord</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_texcoord</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span>
<span class="w">                 </span><span class="n">total_vertices</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
<span class="w">                 </span><span class="n">texcoords_data</span><span class="p">,</span><span class="w"> </span>
<span class="w">                 </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">texcoords_data</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id42">
<h4>4. 修改着色器<a class="headerlink" href="#id42" title="Link to this heading"></a></h4>
<p><strong>顶点着色器</strong>:</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">uMVP</span><span class="p">;</span>
<span class="k">varying</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">vNormal</span><span class="p">;</span>
<span class="k">varying</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">vTexCoord</span><span class="p">;</span><span class="w">  </span><span class="c1">// 新增</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uMVP</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_Vertex</span><span class="p">;</span>
<span class="w">    </span><span class="n">vNormal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">gl_NormalMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">gl_Normal</span><span class="p">;</span>
<span class="w">    </span><span class="n">vTexCoord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">gl_MultiTexCoord0</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span><span class="w">  </span><span class="c1">// 传递 UV 坐标</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>片段着色器</strong>:</p>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="k">uniform</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">uLightDir</span><span class="p">;</span>
<span class="k">uniform</span><span class="w"> </span><span class="kt">sampler2D</span><span class="w"> </span><span class="n">uTexture</span><span class="p">;</span><span class="w">  </span><span class="c1">// 纹理采样器</span>
<span class="k">varying</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">vNormal</span><span class="p">;</span>
<span class="k">varying</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">vTexCoord</span><span class="p">;</span><span class="w">  </span><span class="c1">// 新增</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 光照计算</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">vNormal</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">uLightDir</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">),</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">0.2</span><span class="p">);</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">lighting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ambient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">diff</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 采样纹理</span>
<span class="w">    </span><span class="kt">vec3</span><span class="w"> </span><span class="n">texColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texture2D</span><span class="p">(</span><span class="n">uTexture</span><span class="p">,</span><span class="w"> </span><span class="n">vTexCoord</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 纹理 × 光照</span>
<span class="w">    </span><span class="nb">gl_FragColor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">texColor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">lighting</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id43">
<h4>5. 渲染时绑定纹理<a class="headerlink" href="#id43" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">GLint</span><span class="w"> </span><span class="n">g_loc_texture</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 编译着色器...</span>
<span class="w">    </span><span class="n">g_loc_texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">program</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;uTexture&quot;</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 创建纹理</span>
<span class="w">    </span><span class="n">create_checkerboard_texture</span><span class="p">();</span>
<span class="w">    </span><span class="n">create_texture_vbo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">render</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">glUseProgram</span><span class="p">(</span><span class="n">program</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置 MVP 和光源...</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 绑定纹理到纹理单元 0</span>
<span class="w">    </span><span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">g_texture</span><span class="p">);</span>
<span class="w">    </span><span class="n">glUniform1i</span><span class="p">(</span><span class="n">g_loc_texture</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 采样器绑定到纹理单元 0</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 启用纹理坐标数组</span>
<span class="w">    </span><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span>
<span class="w">    </span><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_NORMAL_ARRAY</span><span class="p">);</span>
<span class="w">    </span><span class="n">glEnableClientState</span><span class="p">(</span><span class="n">GL_TEXTURE_COORD_ARRAY</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glVertexPointer</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_normal</span><span class="p">);</span>
<span class="w">    </span><span class="n">glNormalPointer</span><span class="p">(</span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">g_vbo_texcoord</span><span class="p">);</span>
<span class="w">    </span><span class="n">glTexCoordPointer</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FLOAT</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 2 个分量 (u, v)</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">total_vertices</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_VERTEX_ARRAY</span><span class="p">);</span>
<span class="w">    </span><span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_NORMAL_ARRAY</span><span class="p">);</span>
<span class="w">    </span><span class="n">glDisableClientState</span><span class="p">(</span><span class="n">GL_TEXTURE_COORD_ARRAY</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="id44">
<h3>完整示例: 带纹理的旋转立方体<a class="headerlink" href="#id44" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">create_cube_with_texture</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 立方体顶点 (8 个顶点展开为 36 个)</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">positions</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 前面</span>
<span class="w">        </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 后面</span>
<span class="w">        </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">-1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span>
<span class="w">        </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w">   </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// ... 其他 4 个面</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// UV 坐标</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">texcoords</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 前面</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// 后面</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// ... 其他 4 个面</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 创建 VBO</span>
<span class="w">    </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vbo_position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vbo_position</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">positions</span><span class="p">),</span><span class="w"> </span><span class="n">positions</span><span class="p">,</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vbo_texcoord</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="n">vbo_texcoord</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">texcoords</span><span class="p">),</span><span class="w"> </span><span class="n">texcoords</span><span class="p">,</span><span class="w"> </span><span class="n">GL_STATIC_DRAW</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id45">
<h3>纹理参数详解<a class="headerlink" href="#id45" title="Link to this heading"></a></h3>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 过滤模式 (放大/缩小时如何采样)</span>
<span class="n">GL_NEAREST</span><span class="w">  </span><span class="c1">// 最近邻，像素化效果</span>
<span class="n">GL_LINEAR</span><span class="w">   </span><span class="c1">// 线性插值，平滑过渡</span>

<span class="c1">// 包裹模式 (UV 超出 [0,1] 时如何处理)</span>
<span class="n">GL_REPEAT</span><span class="w">   </span><span class="c1">// 重复平铺</span>
<span class="n">GL_CLAMP</span><span class="w">    </span><span class="c1">// 边缘拉伸</span>
<span class="n">GL_MIRRORED_REPEAT</span><span class="w">  </span><span class="c1">// 镜像重复</span>
</pre></div>
</div>
</section>
<section id="id46">
<h3>关键 API<a class="headerlink" href="#id46" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>函数</p></th>
<th class="head"><p>作用</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glGenTextures(n,</span> <span class="pre">&amp;id)</span></code></p></td>
<td><p>创建纹理对象</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glBindTexture(target,</span> <span class="pre">id)</span></code></p></td>
<td><p>绑定纹理</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glTexImage2D(...)</span></code></p></td>
<td><p>上传图片数据</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glTexParameteri(...)</span></code></p></td>
<td><p>设置过滤/包裹模式</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glActiveTexture(unit)</span></code></p></td>
<td><p>激活纹理单元</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glUniform1i(loc,</span> <span class="pre">unit)</span></code></p></td>
<td><p>绑定采样器</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id47">
<h3>关键收获<a class="headerlink" href="#id47" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>✅ 理解 UV 坐标映射原理</p></li>
<li><p>✅ 掌握纹理创建和上传流程</p></li>
<li><p>✅ 理解纹理采样和插值机制</p></li>
<li><p>✅ 实现带纹理的 3D 模型渲染</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="id48">
<h2>扩展: 加载真实图片纹理<a class="headerlink" href="#id48" title="Link to this heading"></a></h2>
<section id="stb-image-h">
<h3>使用 stb_image.h<a class="headerlink" href="#stb-image-h" title="Link to this heading"></a></h3>
<p><strong>stb_image</strong> 是一个单头文件的图像加载库，支持多种格式。</p>
<section id="id49">
<h4>1. 下载库文件<a class="headerlink" href="#id49" title="Link to this heading"></a></h4>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 下载到项目目录</span>
wget<span class="w"> </span>https://raw.githubusercontent.com/nothings/stb/master/stb_image.h
</pre></div>
</div>
<p>或手动下载: <a class="reference external" href="https://github.com/nothings/stb/blob/master/stb_image.h">https://github.com/nothings/stb/blob/master/stb_image.h</a></p>
</section>
<section id="id50">
<h4>2. 集成到代码<a class="headerlink" href="#id50" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// 在一个 .c 文件中定义实现</span>
<span class="cp">#define STB_IMAGE_IMPLEMENTATION</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stb_image.h&quot;</span>

<span class="c1">// 其他文件只需包含头文件</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;stb_image.h&quot;</span>
</pre></div>
</div>
</section>
<section id="id51">
<h4>3. 加载纹理函数<a class="headerlink" href="#id51" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">GLuint</span><span class="w"> </span><span class="nf">load_texture</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 翻转 Y 轴以匹配 OpenGL 坐标系</span>
<span class="w">    </span><span class="n">stbi_set_flip_vertically_on_load</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 加载图片 (强制转换为 RGB)</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stbi_load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">channels</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Failed to load texture: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">filename</span><span class="p">);</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Reason: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stbi_failure_reason</span><span class="p">());</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Loaded texture: %s (%dx%d, %d channels)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">           </span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">channels</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 创建 OpenGL 纹理</span>
<span class="w">    </span><span class="n">GLuint</span><span class="w"> </span><span class="n">texture</span><span class="p">;</span>
<span class="w">    </span><span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">texture</span><span class="p">);</span>
<span class="w">    </span><span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">texture</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 上传数据</span>
<span class="w">    </span><span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                 </span><span class="n">GL_RGB</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置过滤模式</span>
<span class="w">    </span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINEAR</span><span class="p">);</span>
<span class="w">    </span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINEAR</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 设置包裹模式</span>
<span class="w">    </span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span><span class="w"> </span><span class="n">GL_REPEAT</span><span class="p">);</span>
<span class="w">    </span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span><span class="w"> </span><span class="n">GL_REPEAT</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 释放 CPU 内存</span>
<span class="w">    </span><span class="n">stbi_image_free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">texture</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id52">
<h4>4. 使用示例<a class="headerlink" href="#id52" title="Link to this heading"></a></h4>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">init_textures</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 尝试加载外部文件</span>
<span class="w">    </span><span class="n">g_texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_texture</span><span class="p">(</span><span class="s">&quot;textures/wood.png&quot;</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// 如果失败，使用程序生成的纹理</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">g_texture</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Using procedural checkerboard texture</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">create_checkerboard_texture</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id53">
<h4>5. 支持的格式<a class="headerlink" href="#id53" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p>PNG (推荐，支持透明度)</p></li>
<li><p>JPG/JPEG (压缩格式)</p></li>
<li><p>BMP (无压缩)</p></li>
<li><p>TGA</p></li>
<li><p>GIF (仅第一帧)</p></li>
<li><p>PSD (Photoshop)</p></li>
<li><p>HDR (高动态范围)</p></li>
</ul>
</section>
<section id="id54">
<h4>6. 高级选项<a class="headerlink" href="#id54" title="Link to this heading"></a></h4>
<p><strong>加载 RGBA</strong> (带透明度):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stbi_load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">channels</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">GL_RGBA</span><span class="p">,</span><span class="w"> </span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">             </span><span class="n">GL_RGBA</span><span class="p">,</span><span class="w"> </span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>生成 Mipmap</strong> (多级渐远纹理):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">glTexImage2D</span><span class="p">(...);</span>
<span class="n">glGenerateMipmap</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span><span class="w"> </span><span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span><span class="w"> </span><span class="n">GL_LINEAR_MIPMAP_LINEAR</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="id55">
<h3>对比总结<a class="headerlink" href="#id55" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>方式</p></th>
<th class="head"><p>优点</p></th>
<th class="head"><p>缺点</p></th>
<th class="head"><p>适用场景</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>程序生成</p></td>
<td><p>无依赖，便于调试</p></td>
<td><p>效果简单</p></td>
<td><p>学习、原型</p></td>
</tr>
<tr class="row-odd"><td><p>stb_image</p></td>
<td><p>真实效果，格式丰富</p></td>
<td><p>需要外部文件</p></td>
<td><p>实际项目</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id56">
<h3>资源推荐<a class="headerlink" href="#id56" title="Link to this heading"></a></h3>
<p><strong>免费纹理网站</strong>:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://polyhaven.com/textures">https://polyhaven.com/textures</a> (CC0 许可)</p></li>
<li><p><a class="reference external" href="https://www.textures.com">https://www.textures.com</a> (需注册)</p></li>
<li><p><a class="reference external" href="https://ambientcg.com">https://ambientcg.com</a> (CC0 许可)</p></li>
</ul>
<p><strong>纹理制作工具</strong>:</p>
<ul class="simple">
<li><p>GIMP (免费)</p></li>
<li><p>Photoshop</p></li>
<li><p>Substance Designer (专业)</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="id57">
<h2>总结与进阶方向<a class="headerlink" href="#id57" title="Link to this heading"></a></h2>
<section id="id58">
<h3>你已经掌握的技能<a class="headerlink" href="#id58" title="Link to this heading"></a></h3>
<p>✅ <strong>着色器编程</strong>: 编写顶点和片段着色器，控制渲染管线<br />
✅ <strong>数据传递</strong>: 使用 Uniform 从 CPU 向 GPU 传递参数<br />
✅ <strong>矩阵变换</strong>: 自己构建投影、视图、模型矩阵<br />
✅ <strong>高效渲染</strong>: 使用 VBO 将数据存储在 GPU 显存<br />
✅ <strong>纹理映射</strong>: 为 3D 模型贴图，实现真实感渲染</p>
</section>
<section id="id59">
<h3>完整渲染流程回顾<a class="headerlink" href="#id59" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1. 初始化阶段 (执行一次)
   ├─ 编译着色器 (glCompileShader)
   ├─ 创建 VBO (glBufferData)
   ├─ 创建纹理 (glTexImage2D)
   └─ 获取 Uniform 位置 (glGetUniformLocation)

2. 渲染循环 (每帧执行)
   ├─ 计算 MVP 矩阵
   ├─ 设置 Uniform (glUniform*)
   ├─ 绑定 VBO 和纹理
   └─ 绘制 (glDrawArrays)
</pre></div>
</div>
</section>
<section id="id60">
<h3>下一步进阶方向<a class="headerlink" href="#id60" title="Link to this heading"></a></h3>
<section id="opengl-3-0">
<h4>1. 现代 OpenGL (3.0+)<a class="headerlink" href="#opengl-3-0" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>VAO</strong> (Vertex Array Object): 封装顶点属性状态</p></li>
<li><p><strong>glVertexAttribPointer</strong>: 替代固定管线函数</p></li>
<li><p><strong>GLSL 3.30+</strong>: 使用 <code class="docutils literal notranslate"><span class="pre">in</span></code>/<code class="docutils literal notranslate"><span class="pre">out</span></code> 替代 <code class="docutils literal notranslate"><span class="pre">attribute</span></code>/<code class="docutils literal notranslate"><span class="pre">varying</span></code></p></li>
</ul>
<div class="highlight-glsl notranslate"><div class="highlight"><pre><span></span><span class="c1">// 现代 GLSL</span>
<span class="cp">#version 330 core</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">aPosition</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">aNormal</span><span class="p">;</span>
<span class="k">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">aTexCoord</span><span class="p">;</span>

<span class="k">out</span><span class="w"> </span><span class="kt">vec3</span><span class="w"> </span><span class="n">vNormal</span><span class="p">;</span>
<span class="k">out</span><span class="w"> </span><span class="kt">vec2</span><span class="w"> </span><span class="n">vTexCoord</span><span class="p">;</span>

<span class="k">uniform</span><span class="w"> </span><span class="kt">mat4</span><span class="w"> </span><span class="n">uMVP</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uMVP</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">vec4</span><span class="p">(</span><span class="n">aPosition</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="n">vNormal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aNormal</span><span class="p">;</span>
<span class="w">    </span><span class="n">vTexCoord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aTexCoord</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id61">
<h4>2. 高级光照<a class="headerlink" href="#id61" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>Phong 光照</strong>: 环境光 + 漫反射 + 镜面反射</p></li>
<li><p><strong>法线贴图</strong>: 增加表面细节</p></li>
<li><p><strong>阴影映射</strong>: 实时阴影</p></li>
</ul>
</section>
<section id="id62">
<h4>3. 性能优化<a class="headerlink" href="#id62" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>EBO</strong> (Element Buffer Object): 避免顶点重复</p></li>
<li><p><strong>实例化渲染</strong>: 绘制大量相同物体</p></li>
<li><p><strong>视锥剔除</strong>: 只渲染可见物体</p></li>
</ul>
</section>
<section id="id63">
<h4>4. 高级纹理<a class="headerlink" href="#id63" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>立方体贴图</strong>: 天空盒、环境反射</p></li>
<li><p><strong>多重纹理</strong>: 混合多张纹理</p></li>
<li><p><strong>帧缓冲对象</strong>: 离屏渲染、后处理效果</p></li>
</ul>
</section>
<section id="id64">
<h4>5. 几何处理<a class="headerlink" href="#id64" title="Link to this heading"></a></h4>
<ul class="simple">
<li><p><strong>几何着色器</strong>: 动态生成几何体</p></li>
<li><p><strong>曲面细分</strong>: 动态细分网格</p></li>
</ul>
</section>
</section>
<section id="id65">
<h3>推荐学习资源<a class="headerlink" href="#id65" title="Link to this heading"></a></h3>
<p><strong>在线教程</strong>:</p>
<ul class="simple">
<li><p>LearnOpenGL (<a class="reference external" href="https://learnopengl.com">https://learnopengl.com</a>) - 现代 OpenGL 教程</p></li>
<li><p>OpenGL Tutorial (<a class="reference external" href="http://www.opengl-tutorial.org">http://www.opengl-tutorial.org</a>) - 实用示例</p></li>
</ul>
<p><strong>书籍</strong>:</p>
<ul class="simple">
<li><p>《OpenGL 编程指南》(红宝书)</p></li>
<li><p>《OpenGL SuperBible》(蓝宝书)</p></li>
</ul>
<p><strong>工具</strong>:</p>
<ul class="simple">
<li><p>RenderDoc - GPU 调试工具</p></li>
<li><p>Nsight Graphics - NVIDIA GPU 分析工具</p></li>
</ul>
</section>
<section id="id66">
<h3>实践项目建议<a class="headerlink" href="#id66" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><strong>3D 模型查看器</strong>: 加载 OBJ/FBX，支持旋转、缩放</p></li>
<li><p><strong>简单游戏引擎</strong>: 场景管理、碰撞检测、物理模拟</p></li>
<li><p><strong>粒子系统</strong>: 火焰、烟雾、爆炸效果</p></li>
<li><p><strong>地形渲染</strong>: 高度图、LOD、植被</p></li>
</ol>
</section>
</section>
<hr class="docutils" />
<section id="id67">
<h2>附录<a class="headerlink" href="#id67" title="Link to this heading"></a></h2>
<section id="id68">
<h3>核心概念速查<a class="headerlink" href="#id68" title="Link to this heading"></a></h3>
<section id="id69">
<h4>着色器类型<a class="headerlink" href="#id69" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>着色器</p></th>
<th class="head"><p>执行时机</p></th>
<th class="head"><p>执行次数</p></th>
<th class="head"><p>主要职责</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>顶点着色器</p></td>
<td><p>每个顶点</p></td>
<td><p>顶点数 (如 740)</p></td>
<td><p>坐标变换</p></td>
</tr>
<tr class="row-odd"><td><p>片段着色器</p></td>
<td><p>每个像素</p></td>
<td><p>像素数 (如 20万)</p></td>
<td><p>计算颜色</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id70">
<h4>变量类型<a class="headerlink" href="#id70" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>类型</p></th>
<th class="head"><p>来源</p></th>
<th class="head"><p>特点</p></th>
<th class="head"><p>示例</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>Attribute</strong></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">glVertex*()</span></code></p></td>
<td><p>每个顶点不同</p></td>
<td><p>位置、法线、UV</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Uniform</strong></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">glUniform*()</span></code></p></td>
<td><p>全局共享</p></td>
<td><p>矩阵、光源、时间</p></td>
</tr>
<tr class="row-even"><td><p><strong>Varying</strong></p></td>
<td><p>顶点着色器输出</p></td>
<td><p>GPU 自动插值</p></td>
<td><p>传递法线、颜色</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id71">
<h4>坐标变换<a class="headerlink" href="#id71" title="Link to this heading"></a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>模型空间 ──Model──→ 世界空间 ──View──→ 相机空间 ──Projection──→ 裁剪空间
  (0,0,0)            (场景中心)        (相机视角)          (屏幕坐标)

MVP 矩阵 = Projection × View × Model
</pre></div>
</div>
</section>
</section>
<section id="id72">
<h3>API 速查表<a class="headerlink" href="#id72" title="Link to this heading"></a></h3>
<section id="id73">
<h4>着色器相关<a class="headerlink" href="#id73" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>函数</p></th>
<th class="head"><p>作用</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glCreateShader(type)</span></code></p></td>
<td><p>创建着色器</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glShaderSource(...)</span></code></p></td>
<td><p>设置源代码</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glCompileShader(s)</span></code></p></td>
<td><p>编译</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glCreateProgram()</span></code></p></td>
<td><p>创建程序</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glAttachShader(p,</span> <span class="pre">s)</span></code></p></td>
<td><p>附加着色器</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glLinkProgram(p)</span></code></p></td>
<td><p>链接</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glUseProgram(p)</span></code></p></td>
<td><p>启用/禁用</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id74">
<h4>Uniform 相关<a class="headerlink" href="#id74" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>函数</p></th>
<th class="head"><p>作用</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glGetUniformLocation(p,</span> <span class="pre">&quot;name&quot;)</span></code></p></td>
<td><p>获取位置</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glUniform1f(loc,</span> <span class="pre">v)</span></code></p></td>
<td><p>设置 float</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glUniform3f(loc,</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code></p></td>
<td><p>设置 vec3</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glUniformMatrix4fv(loc,</span> <span class="pre">...)</span></code></p></td>
<td><p>设置 mat4</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id75">
<h4>VBO 相关<a class="headerlink" href="#id75" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>函数</p></th>
<th class="head"><p>作用</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glGenBuffers(n,</span> <span class="pre">&amp;id)</span></code></p></td>
<td><p>创建 VBO</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glBindBuffer(target,</span> <span class="pre">id)</span></code></p></td>
<td><p>绑定 VBO</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glBufferData(target,</span> <span class="pre">size,</span> <span class="pre">data,</span> <span class="pre">usage)</span></code></p></td>
<td><p>上传数据</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glVertexPointer(size,</span> <span class="pre">type,</span> <span class="pre">stride,</span> <span class="pre">ptr)</span></code></p></td>
<td><p>指定顶点格式</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glDrawArrays(mode,</span> <span class="pre">first,</span> <span class="pre">count)</span></code></p></td>
<td><p>绘制</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id76">
<h4>纹理相关<a class="headerlink" href="#id76" title="Link to this heading"></a></h4>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>函数</p></th>
<th class="head"><p>作用</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glGenTextures(n,</span> <span class="pre">&amp;id)</span></code></p></td>
<td><p>创建纹理对象</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glBindTexture(target,</span> <span class="pre">id)</span></code></p></td>
<td><p>绑定纹理</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glTexImage2D(...)</span></code></p></td>
<td><p>上传图片数据</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">glTexParameteri(...)</span></code></p></td>
<td><p>设置过滤/包裹模式</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">glActiveTexture(unit)</span></code></p></td>
<td><p>激活纹理单元</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id77">
<h3>OpenGL 函数命名规则<a class="headerlink" href="#id77" title="Link to this heading"></a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>gl      Vertex    3       f       v
│         │       │       │       │
│         │       │       │       └── v = vector (数组指针)
│         │       │       └── f = float 类型
│         │       └── 3 = 3个分量 (x,y,z)
│         └── 功能名
└── OpenGL 前缀
</pre></div>
</div>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>后缀</p></th>
<th class="head"><p>含义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">3f</span></code></p></td>
<td><p>3 个 float 参数</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">3fv</span></code></p></td>
<td><p>float[3] 数组指针</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">4d</span></code></p></td>
<td><p>4 个 double 参数</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">Matrix4fv</span></code></p></td>
<td><p>4x4 float 矩阵</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id78">
<h3>常见问题<a class="headerlink" href="#id78" title="Link to this heading"></a></h3>
<p><strong>Q: 着色器编译失败？</strong></p>
<ul class="simple">
<li><p>检查 GLSL 语法错误</p></li>
<li><p>使用 <code class="docutils literal notranslate"><span class="pre">glGetShaderInfoLog</span></code> 查看错误信息</p></li>
<li><p>确认 OpenGL 版本支持的 GLSL 版本</p></li>
</ul>
<p><strong>Q: 纹理是黑色的？</strong></p>
<ul class="simple">
<li><p>检查是否调用 <code class="docutils literal notranslate"><span class="pre">glBindTexture()</span></code></p></li>
<li><p>检查 UV 坐标是否正确传递</p></li>
<li><p>检查采样器 uniform 是否设置</p></li>
</ul>
<p><strong>Q: VBO 不显示？</strong></p>
<ul class="simple">
<li><p>检查是否调用 <code class="docutils literal notranslate"><span class="pre">glEnableClientState()</span></code></p></li>
<li><p>检查顶点数据是否正确展开</p></li>
<li><p>确认 <code class="docutils literal notranslate"><span class="pre">glDrawArrays</span></code> 的顶点数量正确</p></li>
</ul>
<p><strong>Q: 矩阵变换不正确？</strong></p>
<ul class="simple">
<li><p>检查矩阵乘法顺序 (MVP = P × V × M)</p></li>
<li><p>确认使用列主序存储</p></li>
<li><p>检查角度是否转换为弧度</p></li>
</ul>
</section>
</section>
<hr class="docutils" />
<section id="id79">
<h2>代码文件说明<a class="headerlink" href="#id79" title="Link to this heading"></a></h2>
<p>本教程的示例代码采用<strong>渐进式演进</strong>方式：</p>
<ul class="simple">
<li><p><strong>OpenGL-demo.c</strong> - 主示例代码</p>
<ul>
<li><p>包含所有 5 个学习步骤的完整实现</p></li>
<li><p>通过注释标记不同阶段的代码</p></li>
<li><p>便于理解从简单到复杂的演进过程</p></li>
</ul>
</li>
</ul>
<p><strong>为什么在同一个文件中演进？</strong></p>
<ul class="simple">
<li><p>✅ 避免代码重复和维护困难</p></li>
<li><p>✅ 保留完整的演进历史</p></li>
<li><p>✅ 更符合实际开发流程：在现有代码上迭代改进</p></li>
</ul>
<p><strong>如何使用</strong>:</p>
<ol class="arabic simple">
<li><p>从头阅读，理解每个步骤的改动</p></li>
<li><p>运行完整代码，查看最终效果</p></li>
<li><p>注释掉高级功能，回退到简单版本进行学习</p></li>
</ol>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="video.html" class="btn btn-neutral float-left" title="视频方案" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="vector.html" class="btn btn-neutral float-right" title="矢量图形方案" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>